=== CÃ“DIGO COMPLETO DO Miniconcha ===
Gerado em: Fri Dec 19 05:38:26 PM -03 2025
======================================

/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: ast_converter.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_converter.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 04:31:27 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 19:32:12 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "executor.h"
#include "libft/libft.h"

static	t_node *create_simple_command(t_token **tokens);

t_node	*create_ast_from_tokens(t_token *tokens)
{
	t_node	*head;
	t_node	*current;
	t_node	*node;
	t_node	*pipe_node;

	head = NULL;
	current = NULL;
	while (tokens)
	{
		if (tokens->type == PIPE)
		{
			pipe_node = malloc(sizeof(t_node));
			if (!pipe_node)
				return NULL;
			ft_memset(pipe_node, 0, sizeof(t_node));
			pipe_node->type = AST_PIPE;
			pipe_node->left = head;
			tokens = tokens->next;
			pipe_node->right = create_ast_from_tokens(tokens);
			return pipe_node;
		}
		node = NULL;
		if (tokens->type == WORD)
			node = create_simple_command(&tokens);
		else
			node = create_simple_command(&tokens);
		if (!node)
			return NULL;
		if (!head)
			head = node;
		else
			current->right = node;
		current = node;
		tokens = tokens->next;
	}
	return head;
}

static	t_node *create_simple_command(t_token **tokens)
{
	t_node	*node;
	int	argc;
	t_token	*temp;
	char	**argv;
	char	*dup;

	node = malloc(sizeof(t_node));
	if (!node)
		return NULL;
	ft_memset(node, 0, sizeof(t_node));
	node->type = BUILTIN;
	node->is_pipeline = 0;
	argc = 0;
	temp = *tokens;
	while (temp && (temp->type == WORD || is_redirection(temp->type)))
	{
		if (temp->type == WORD)
			argc++;
		temp = temp->next;
	}
	argv = malloc(sizeof(char *) * (argc + 1));
	if (!argv)
	{
		free(node);
		return NULL;
	}
	argc = 0;
	temp = *tokens;
	while (temp && (temp->type == WORD || is_redirection(temp->type)))
	{
		if (temp->type == WORD)
		{
			dup = ft_strdup(temp->value);
			if (!dup)
			{
				while (argc > 0)
					free(argv[--argc]);
				free(argv);
				free(node);
				return NULL;
			}
			argv[argc++] = dup;
		}
		temp = temp->next;
	}
	argv[argc] = NULL;
	node->cmds = argv;
	node->env_list = NULL;
	return node;
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: ast_utils.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 03:09:12 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/06 03:11:05 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ast_utils.h"
#include "libft/libft.h"

void	free_ast(t_node *ast)
{
	char	**cmd;
	
	if (!ast)
		return;
	if (ast->type == AST_PIPE)
	{
		free_ast(ast->left);
		free_ast(ast->right);
	}
	else
	{
		if (ast->cmds)
		{
			cmd = ast->cmds;
			while (*cmd)
				free(*cmd++);
			free(ast->cmds);
		}
	}
	free(ast);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: builtins_adapter.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_adapter.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 04:31:27 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 19:32:12 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"
#include "executor.h"
#include "minishell.h"
#include "ast_converter.h"
#include "libft/libft.h"

int adapter_echo(char **args, char **envp)
{
	t_token	*tokens;
	int	result;
	
	(void)envp;
	tokens = create_token_from_args(args);
	result = ft_echo(tokens);
	free_tokens(tokens);
	return result;
}

int adapter_cd(char **args, char **envp)
{
	t_token	*tokens;
	int	result;

	tokens = create_token_from_args(args);
	result = ft_cd(tokens,(char ***)&envp);
	free_tokens(tokens);
	return result;
}

int adapter_pwd(char **args, char **envp)
{
	(void)args;
	(void)envp;
	return ft_pwd();
}

int adapter_env(char **args, char **envp)
{
	(void)args;
	return ft_env(envp);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: builtins.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 16:05:59 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 18:59:34 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"
#include "libft/libft.h"

int	is_builtin(char *cmd)
{
	if (!ft_strcmp(cmd, "echo"))
		return (ECHO);
	if (!ft_strcmp(cmd, "pwd"))
		return (PWD);
	if (!ft_strcmp(cmd, "env"))
		return (ENV);
	if (!ft_strcmp(cmd, "cd"))
		return (CD);
	if (!ft_strcmp(cmd, "export"))
		return (EXPORT);
	if (!ft_strcmp(cmd, "unset"))
		return (UNSET);
	if (!ft_strcmp(cmd, "exit"))
		return (EXIT);
	return (NOT_BUILTIN);
}

int	execute_builtin(t_token *tokens, char ***envp, int *exit_status)
{
	(void)envp;
	if (!tokens)
		return (-1);
	if (is_builtin(tokens->value) != NOT_BUILTIN)
	{
		if (is_builtin(tokens->value) == ECHO)
			return (ft_echo(tokens));
		else if (is_builtin(tokens->value) == PWD)
			return (ft_pwd());
		else if (is_builtin(tokens->value) == ENV)
			return (ft_env(*envp));
		else if (is_builtin(tokens->value) == CD)
			return (ft_cd(tokens, envp));
		else if (is_builtin(tokens->value) == EXPORT)
			return (ft_export(tokens, envp));
		else if (is_builtin(tokens->value) == UNSET)
			return (ft_unset(tokens, envp));
		else if (is_builtin(tokens->value) == EXIT)
			return (ft_exit(tokens, exit_status));
	}
	return (-1);
}

int	ft_echo(t_token *tokens)
{
	int	i;
	int	newline;

	i = 1;
	newline = 1;
	if (tokens->next && !ft_strcmp(tokens->next->value, "-n"))
	{
		newline = 0;
		i = 2;
	}
	while (tokens->next && i > 0 && tokens->next->type == WORD)
	{
		ft_putstr(tokens->next->value);
		tokens = tokens->next;
		if (tokens->next && tokens->next->type == WORD)
			ft_putchar(' ');
	}
	if (newline)
		ft_putchar('\n');
	return (0);
}

int	ft_pwd(void)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if(!cwd)
		return (1);
	ft_putstr(cwd);
	ft_putchar('\n');
	free(cwd);
	return (0);
}

int	ft_env(char **envp)
{
	int	i;
	
	i = 0;
	while (envp[i])
	{
		ft_putstr(envp[i]);
		ft_putchar('\n');
		i++;
	}
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: builtins_env_adapter.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_env_adapter.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 04:31:27 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 19:32:12 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"
#include "executor.h"
#include "minishell.h"
#include "libft/libft.h"
#include "ast_converter.h"

int adapter_export(char **args, char **envp)
{
	t_token	*tokens;
	int	result;
	
	(void)envp;
	tokens = create_token_from_args(args);
	result = ft_export(tokens, (char ***)&envp);
	free_tokens(tokens);
	return result;
}

int adapter_unset(char **args, char **envp)
{
	t_token	*tokens;
	int	result;

	(void)envp;
	tokens = create_token_from_args(args);
	if (!tokens)
		return 1;
	result = ft_unset(tokens, (char ***)&envp);
	free_tokens(tokens);
	return result;
}

int adapter_exit(char **args, char **envp)
{
	t_token	*tokens;
	int	result;

	(void)envp;
	tokens = create_token_from_args(args);
	if (!tokens)
		return 1;
	result = ft_exit(tokens, NULL);
	free_tokens(tokens);
	return result;
}

t_token *create_token_from_args(char **args)
{
	t_token	*head;
	t_token	*current;
	int	i;
	t_token	*new_token;

	head = NULL;
	current = NULL;
	i = 0;

	while (args[i])
	{
		new_token =  create_token(ft_strdup(args[i]), 
				ft_strlen(args[i]), WORD);
		if (!new_token)
		{
			free_tokens(head);
			return NULL;
		}
		if (!head)
			head = new_token;
		else
			current->next = new_token;
		current = new_token;
		i++;
	}
	return head;
	
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: builtins_env.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_env.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 17:16:37 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 15:39:52 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"
#include "minishell.h"
#include "libft/libft.h"
#include <limits.h>
#include <unistd.h>
#include "env_utils.h"

int	ft_cd(t_token *tokens, char ***envp)
{
	char	*path;
	char	*oldpwd;
	char	cwd[PATH_MAX];
	int		should_free_path;

	should_free_path = 0;
	oldpwd = getcwd(NULL, 0);
	if (!oldpwd)
		return (1);
	if (!tokens->next || !tokens->next->value || tokens->next->value[0] == '\0')
		path = get_env_var("HOME", *envp);
	else if (tokens->next->value[0] == '~')
	{
		path = expand_tilde(tokens->next->value, *envp);
		should_free_path = 1;
	}
	else if (tokens->next->value[0] == '-' && tokens->next->value[1] == '\0')
		path = get_env_var("OLDPWD", *envp);
	else
		path = tokens->next->value;
	if (!path || chdir(path) == -1)
	{
		if (should_free_path)
			free(path);
		free(oldpwd);
		return (1);
	}
	if (getcwd(cwd, sizeof(cwd)) == NULL)
	{
		if (should_free_path)
			free (path);
		free(oldpwd);
		return (1);
	}
	set_env_var("OLDPWD", oldpwd, envp);
	set_env_var("PWD", cwd, envp);
	if (should_free_path)
		free(path);
	free(oldpwd);
	return (0);
}

int	ft_export(t_token *tokens, char ***envp)
{
	char	*value;
	char	*name;
	char	*equal_sign;

	if (!tokens->next)
	{
		ft_env(*envp);
		return (0);
	}
	while (tokens->next && tokens->next->type == WORD)
	{
		equal_sign = ft_strchr(tokens->next->value, '=');
		if (!equal_sign)
		{
			if (!get_env_var(tokens->next->value, *envp))
				return (1);
		}
		else
		{
			name = ft_substr(tokens->next->value, 0, equal_sign - tokens->next->value);
			value = equal_sign + 1;
			if (set_env_var(name, value, envp) == -1)
			{
				free(name);
				return (1);
			}
			free(name);
		}
		tokens = tokens->next;
	}
	return (0);
}

int	ft_unset(t_token *tokens, char ***envp)
{
	int	i;

	i = 1;
	if (!tokens->next)
		return (1);
	while (tokens->next && tokens->next->type == WORD)
	{
		if (unset_env_var(tokens->next->value, envp) == -1)
			return (1);
		tokens = tokens->next;
		i++;
	}
	return (0);
}

int ft_exit(t_token *tokens, int *exit_status)
{
	int	status;

	status = 0;
	if (!tokens->next)
	{
		*exit_status = 0;
		return (0);
	}
	if (tokens->next->type == WORD && !tokens->next->next)
	{
		if (!is_numeric(tokens->next->value))
			return (2);
		status = ft_atoi(tokens->next->value);
		*exit_status = status;
		return (0);
	}
	return (1);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: builtins_env_utils.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_env_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 18:04:40 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 15:08:44 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"
#include "minishell.h"
#include "libft/libft.h"

char	*get_env_var(char *name, char **envp)
{
	int	i;
	int	len;

	i = 0;
	len = ft_strlen(name);
	while (envp[i])
	{
		if (ft_strncmp(envp[i], name, len) == 0 && envp[i][len] == '=')
			return (envp[i] + len + 1);
		i++;
	}
	return (NULL);
}

int	set_env_var(char *name, char *value, char ***envp)
{
	int	i;
	int	len;
	char	*new_var;
	char	*temp;
	char	**new_envp;

	i = 0;
	len = ft_strlen(name);
	while ((*envp)[i])
	{
		if (ft_strncmp((*envp)[i], name, len) == 0 && (*envp)[i][len] == '=')
		{
			free((*envp)[i]);
			temp = ft_strjoin(name, "=");
			if (!temp)
				return (-1);
			new_var = ft_strjoin(temp, value);
			free(temp);
			if (!new_var)
				return (-1);
			(*envp)[i] = new_var;
			return (0);
		}
		i++;
	}
	temp = ft_strjoin(name, "=");
	if (!temp)
		return (-1);
	new_var = ft_strjoin(temp, value);
	free(temp);
	if (!new_var)
		return (-1);
	i = 0;
	while ((*envp)[i])
		i++;
	new_envp = ft_realloc(*envp, i, i + 2);
	if (!new_envp)
	{
		free(new_var);
		return (-1);
	}
	*envp = new_envp;
	(*envp)[i] = new_var;
	(*envp)[i + 1] = NULL;
	return (0);
}

char *expand_tilde(char *path, char **envp)
{
	char *home;
	char *new_path;

	home = get_env_var("HOME", envp);
	if (!home)
		return (ft_strdup(path));
	new_path = ft_strjoin(home, path + 1);
	return (new_path);
}

int	unset_env_var(char *name, char ***envp)
{
	int	i;
	int	len;

	i = 0;
	len = ft_strlen(name);
	while ((*envp)[i])
	{
		if (ft_strncmp((*envp)[i], name, len) == 0 && (*envp)[i][len] == '=')
		{
			free((*envp)[i]);
			while ((*envp)[i + 1])
			{
				(*envp)[i] = (*envp)[i + 1];
				i++;
			}
			(*envp)[i] = NULL;
			return (0);
		}
		i++;
	}
	return (-1);
}

int	is_numeric(char *str)
{
	int	i;

	i = 0;
	if (!str || str[0] == '\0')
		return (0);
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

char **ft_realloc(char **src, int old_size, int new_size)
{
	char **new;
	int	i;

	new = malloc(sizeof(char *) * (new_size));
	if (!new)
		return (NULL);
	i = 0;
	while (i < old_size && src[i])
	{
		new[i] = src[i];
		i++;
	}
	while (i < new_size)
	{
		new[i] = NULL;
		i++;
	}
	free(src);
	return (new);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: env_utils.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/10 18:00:08 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 18:05:41 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "executor.h"
#include "libft/libft.h"
#include "env_utils.h"

char **convert_env_list_to_envp(t_list *env_list)
{
	int	count;
	t_list	*current;
	char	**envp;
	int	i;

	count = 0;
	current = env_list;
	while (current)
	{
		count++;
		current = current->next;
	}
	envp = malloc(sizeof(char *) * (count + 1));
	if (!envp)
		return NULL;
	current = env_list;
	i = 0;
	while (i < count)
	{
		envp[i] = ft_strdup(current->content);
		if (!envp[i])
		{
			while(i > 0)
				free(envp[--i]);
			free(envp);
			return NULL;
		}
		current = current->next;
		i++;
	}
	envp[count] = NULL;
	return envp;
}

t_list	*convert_envp_to_env_list(char **envp)
{
	t_list	*env_list;
	int	i;
	char	*content;
	t_list	*new_node;

	env_list = NULL;
	i = 0;
	while (envp[i])
	{
		content = ft_strdup(envp[i]);
		if (!content)
		{
			free_env_list(env_list);
			return NULL;
		}
		new_node = malloc(sizeof(t_list));
		if (!new_node)
		{
			free(content);
			free_env_list(env_list);
			return NULL;
		}
		new_node->content = content;
		new_node->next = env_list;
		env_list = new_node;
	}
	return env_list;
}

void	free_env_list(t_list *env_list)
{
	t_list	*current;
	t_list	*next;

	current = env_list;
	while (current)
	{
		next = current->next;
		free(current->content);
		free(current);
		current = next;
	}
}

char **copy_envp(char **src)
{
	int	i;
	int	size;
	char	**dest;

	i = 0;
	size = 0;
	while (src[size])
		size++;
	dest = malloc(sizeof(char *) * (size + 1));
	if (!dest)
		return (NULL);
	while (i < size)
	{
		dest[i] = ft_strdup(src[i]);
		if (!dest[i])
		{
			while (i > 0)
				free(dest[--i]);
			free(dest);
			return (NULL);
		}
		i++;
	}
	dest[size] = NULL;
	return (dest);
}

void free_envp(char **envp)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		free(envp[i]);
		i++;
	}
	free(envp);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: executor.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fpedroso <fpedroso@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/22 16:51:07 by fpedroso          #+#    #+#             */
/*   Updated: 2025/12/10 18:41:11 by fpedroso         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "executor.h"
#include "builtins_adapter.h"
#include "get_path.h"
#include "builtins.h"
#include "env_utils.h"
#include "handle_redirections.h"
#include <sys/wait.h>

static void	pipe_logic(t_node *node);
static void	exec_left(int pip[2], t_node *node);
static void	exec_right(int pip[2], t_node *node);
static void init_builtin_table(t_builtin table[N_BUILTINS]);
static void	exec_cmd(t_node *node);
static int	exec_forked_builtin(t_node *node);
static int	exec_builtin(t_node *node);

void    execute_tree(t_node *node)
{
	t_command	temp_cmd;

	if (!node)
		return;
	if (node->type == AST_PIPE)
		pipe_logic(node);
	else
	{
		temp_cmd.args = node->cmds;
		temp_cmd.redirections = NULL;
		temp_cmd.redirections_count = 0;
		handle_redirections(temp_cmd);
		if (node->type == EXT_CMD)
			exec_cmd(node);
		else if (node->is_pipeline && node->type == BUILTIN)
			exec_forked_builtin(node);
		else if (node->type == BUILTIN)
			exec_builtin(node);
		clean_temp_files();
	}
}

static int	exec_forked_builtin(t_node *node)
{
	pid_t	pid;

	pid = fork();
	if (pid == CHILD)
		exec_builtin(node);
	wait(NULL);
	return (1);
}

static int	exec_builtin(t_node *node)
{
	t_builtin	builtin_table[N_BUILTINS];
	int			i;
	char		**envp;
	int		result;
	t_list		*new_env_list;

	init_builtin_table(builtin_table);
	i = 0;
	envp = convert_env_list_to_envp(node->env_list);
	if (!envp)
		return -1;
	while (i < N_BUILTINS)
	{
		if (ft_strcmp(node->cmds[0], builtin_table[i].name) == 0)
		{
			result = builtin_table[i].func(node->cmds, envp);
			new_env_list = convert_envp_to_env_list(envp);
			if (new_env_list)
			{
				free_env_list(node->env_list);
				node->env_list = new_env_list;
			}
			free_envp(envp);
			return result;
		}
		i++;
    	}
	free_envp(envp);
	return -1;
}

static void	exec_cmd(t_node *node)
{
	pid_t	pid;
	char	*path;
	char	**envp;

	pid = fork();
	if (pid == CHILD)
	{
		envp = convert_env_list_to_envp(node->env_list);
		if (!envp)
		{
			perror("Failed to convert environment");
			exit(1);
		}
		path = get_path(node->cmds, node->env_list);
		if (!path || execve(path, node->cmds, envp) == -1)
		{
			free_envp(envp);
			perror("Execve");
			exit(1);
		}
		free_envp(envp);
	}
	wait(NULL);
}

void    init_builtin_table(t_builtin table[N_BUILTINS])
{
    table[0].name = "echo";
    table[0].func = &adapter_echo;

    table[1].name = "cd";
    table[1].func = &adapter_cd;

    table[2].name = "pwd";
    table[2].func = &adapter_pwd;

    table[3].name = "export";
    table[3].func = &adapter_export;

    table[4].name = "unset";
    table[4].func = &adapter_unset;

    table[5].name = "env";
    table[5].func = &adapter_env;

    table[6].name = "exit";
    table[6].func = &adapter_exit;
}

static void	pipe_logic(t_node *node)
{
    pid_t	left_pid;
    pid_t	right_pid;
    int		pip[2];

	if (pipe(pip) != 0)
	{
		perror("Pipe");
		exit(1);
	}
	left_pid = fork();
	if (left_pid == CHILD)
	{
		exec_left(pip, node);
		exit(0);
	}
	close(pip[WRITE]);
	right_pid = fork();
	if (right_pid == CHILD)
	{
		exec_right(pip, node);
		exit(0);
	}
	close(pip[READ]);
	waitpid(left_pid, NULL, 0);
	waitpid(right_pid, NULL, 0);
	clean_temp_files();
}

static void	exec_left(int pip[2], t_node *node)
{
	close(pip[READ]);
	dup2(pip[WRITE], STDOUT_FILENO);
	close(pip[WRITE]);
	execute_tree(node->left);
	exit(0);
}

static void	exec_right(int pip[2], t_node *node)
{
	dup2(pip[READ], STDIN_FILENO);
	close(pip[READ]);
	execute_tree(node->right);
	exit(0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: get_path.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_path.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fpedroso <fpedroso@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/01 00:00:00 by fpedroso          #+#    #+#             */
/*   Updated: 2025/12/01 18:17:05 by fpedroso         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "executor.h"
#include "get_path.h"
#include "env_utils.h"
#include "builtins.h"
#include <limits.h>
#include <unistd.h>

static char	*find_in_path(char *cmd, char *path_env);
static char	*get_path_env(char **envp);
static char	*join_path(char *dir, char *cmd);

char	*get_path(char **cmds, t_list *env_list)
{
	char	*path_env;
	char	*result;
	char	**envp;

	if (!cmds || !cmds[0])
		return (NULL);
	envp = convert_env_list_to_envp(env_list);
	if (!envp)
		return (NULL);
	if (strchr(cmds[0], '/'))
	{
		if (access(cmds[0], X_OK) == 0)
		{
			result = ft_strdup(cmds[0]);
			return (result);
		}
		free_envp(envp);
		return (NULL);
	}
	path_env = get_path_env(envp);
	if (!path_env)
	{
		free_envp(envp);
		return (NULL);
	}
	result = find_in_path(cmds[0], path_env);
	free_envp(envp);
	return (result);
}

static char	*get_path_env(char **envp)
{
	int	i;

	if (!envp)
		return (NULL);
	i = 0;
	while (envp[i])
	{
		if (strncmp(envp[i], "PATH=", 5) == 0)
			return (envp[i] + 5);
		i++;
	}
	return (NULL);
}

static char	*find_in_path(char *cmd, char *path_env)
{
	char	*path_copy;
	char	*dir;
	char	*full_path;
	char	*saveptr;

	path_copy = ft_strdup(path_env);
	if (!path_copy)
		return (NULL);
	dir = strtok_r(path_copy, ":", &saveptr);
	while (dir)
	{
		full_path = join_path(dir, cmd);
		if (full_path && access(full_path, X_OK) == 0)
		{
			free(path_copy);
			return (full_path);
		}
		free(full_path);
		dir = strtok_r(NULL, ":", &saveptr);
	}
	free(path_copy);
	return (NULL);
}

static char	*join_path(char *dir, char *cmd)
{
	char	*result;
	size_t	len;

	if (!dir || !cmd)
		return (NULL);
	
	len = strlen(dir) + strlen(cmd) + 2; // +2 for '/' and '\0'
	result = (char *)malloc(len);
	if (!result)
		return (NULL);
	
	strcpy(result, dir);
	if (dir[strlen(dir) - 1] != '/')
		strcat(result, "/");
	strcat(result, cmd);
	
	return (result);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: handle_redirections.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_redirections.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fpedroso <fpedroso@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/02 18:33:42 by fpedroso          #+#    #+#             */
/*   Updated: 2025/12/02 18:33:42 by fpedroso         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "executor.h"
#include <fcntl.h>
#include "handle_redirections.h"
#include <sys/stat.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

static void set_stdin_redir(t_redirection redirection);
static void set_stdout_redir(t_redirection redirection);
static void set_append_redir(t_redirection redirection);
static void set_heredoc_redir(t_command cmd, char *heredoc_delim);
static void redir_error_message(void);

void	handle_redirections(t_command cmd)
{
	t_redirection_type	redir_type;
	int	i;

	i = -1;
	while (++i < cmd.redirections_count)  
	{
		redir_type = cmd.redirections[i].type;
		if (redir_type == REDIR_IN)
			set_stdin_redir(cmd.redirections[i]);
		else if (redir_type == REDIR_OUT)
			set_stdout_redir(cmd.redirections[i]);
		else if (redir_type == REDIR_APPEND)
			set_append_redir(cmd.redirections[i]);
		else if (redir_type == REDIR_HEREDOC)
			set_heredoc_redir(cmd, cmd.redirections[i].target);
		else
		{
			redir_error_message();
			return;
		}
	}
}

char *create_temp_file(char *delim)
{
	char	*filename;
	int	fd;
	char	*line;

	filename = ft_strdup("/temp/heredoc_XXXXXX");
	fd = mkstemp(filename);
	line = readline("> ");
	while (line)
	{
		if (ft_strcmp(line, delim) == 0)
			break;
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
		line = readline("> ");
	}
	close(fd);
	return filename;
}	

static void	set_heredoc_redir(t_command cmd, char *heredoc_delim)
{
	char	*heredoc_filepath;
	
	heredoc_filepath = create_temp_file(heredoc_delim);
	if (!heredoc_filepath)
	{
		perror("heredoc reader");
		return;
	}
	dup_file_into_stdin(heredoc_filepath);
}

static void	dup_file_into_stdin(char *heredoc_filepath)
{
	int	heredoc_fd;
	
	heredoc_fd = open(heredoc_filepath, O_RDONLY);
	if (heredoc_fd <  0)
	{
		perror("heredoc temp file");
		return;
	}
	dup2(heredoc_fd, STDIN_FILENO);
	if (close(heredoc_fd) < 0)
	{
		perror("heredoc temp file");
		return;
	}
	dup2(heredoc_fd, STDIN_FILENO);
	if (close(heredoc_fd) < 0)
	{
		perror("heredoc temp file close");
		return;
	}
}

static void set_append_redir(t_redirection redirection)
{
	int	fd;

	fd = open(redirection.target, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (fd < 0)
	{
		perror(redirection.target);
		return;
	}
	dup2(fd, STDOUT_FILENO);
	if (close(fd) < 0)
	{
		perror(redirection.target);
		return;
	}
}

static void set_stdout_redir(t_redirection redirection)
{
	int	fd;

	fd = open(redirection.target, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd < 0)
	{
		perror(redirection.target);
		return;
	}
	dup2(fd, STDOUT_FILENO);
	if (close(fd) < 0)
	{
		perror(redirection.target);
		return;
	}
}

static void set_stdin_redir(t_redirection redirection)
{
	int	fd;

	fd = open(redirection.target, O_RDONLY);
	if (fd < 0)
	{
		perror(redirection.target);
		return;
	}
	dup2(fd, STDIN_FILENO);
	if (close(fd) < 0)
	{
		perror(redirection.target);
		return;
	}
}

static void redir_error_message(void)
{
	perror("Invalid redirection");
}

void	clean_temp_files(void)
{
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: main.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 04:31:27 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 19:32:12 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"
#include "executor.h"
#include "ast_utils.h"
#include "ast_converter.h"
#include <unistd.h>

extern char **environ;

int	main(void)
{
	char	*input;
	char	**my_envp;
	int		exit_status;
	t_node	*ast;
	t_token	*tokens;

	exit_status = 0;
	my_envp = copy_envp(environ);
	if (!my_envp)
		return (1);
	while (1)
	{
		input = readline("miniconcha> ");
		if (!input)
			break ;
		if (input[0])
			add_history(input);
		tokens = tokenize(input);
		ast = create_ast_from_tokens(tokens);
		if (ast)
		{
			if (ast->type == BUILTIN)
			{
				execute_builtin(tokens, &my_envp, &exit_status);
				if (ast->cmds && ft_strcmp(ast->cmds[0], "exit") == 0)
					break;
			}
			else
				execute_tree(ast);
			free_ast(ast);
		}
		free_tokens(tokens);
		free(input);
	}
	free_envp(my_envp);
	return exit_status;
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: minishell_utils.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 04:31:27 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/10 19:32:12 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int is_redirection(t_token_type type)
{
	return (type == TOK_IN || type == TOK_OUT ||
			type == APPEND || type == HEREDOC);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: token_creator.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_creator.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 03:20:10 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/06 03:54:51 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	create_word_token(t_token **tokens, char **input)
{
	char	*start = *input;
	int		in_quote = 0;
	char	quote_char = 0;

	while (**input)
	{
		if ((**input == '\'' || **input == '"') && !in_quote)
		{
			quote_char = **input;
			in_quote = 1;
			(*input)++;
			continue;
		}
		if (**input == quote_char && in_quote)
		{
			in_quote = 0;
			(*input)++;
			continue;
		}
		if (!in_quote && (**input == ' ' || **input == '\t' || is_operator(**input)))
			break;
		else
			(*input)++;
	}
	add_token(tokens, create_token(start, *input - start, WORD));
}

void	create_operator_token(t_token **tokens, char **input)
{
	t_token_type	type;

	if (is_double_operator(*input))
	{
		if ((*input)[0] == '>' && (*input)[1] == '>')
			type = APPEND;
		else
			type = HEREDOC;
		*input += 2;
	}
	else
	{
		if (**input == '|')
			type = PIPE;
		else if (**input == '>')
			type = TOK_OUT;
		else if (**input == '<')
			type = TOK_IN;
		(*input)++;
	}
	add_token(tokens, create_token(NULL, 0, type));
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: tokenizer.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 03:09:12 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/06 03:11:05 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token *tokenize(char *input)
{
	t_token *tokens = NULL;

	while (*input)
	{
		skip_spaces(&input);
		if (is_operator(*input))
			create_operator_token(&tokens, &input);
		else
			create_word_token(&tokens, &input);
	}
	return tokens;
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: tokenizer_utils.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 03:13:12 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/06 03:18:09 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	skip_spaces(char **input)
{
	while (**input && (**input == ' ' || **input == '\t'))
		(*input)++;
}

int	is_operator(char c)
{
	return (c == '|' || c == '>' || c == '<');
}

int	is_double_operator(char *input)
{
	return ((input[0] == '>' && input[1] == '>') ||
			(input[0] == '<' && input[1] == '<'));
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        ARQUIVO: token_utils.c */
/*                                                                            */
/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lcosta-a <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/06 03:34:21 by lcosta-a          #+#    #+#             */
/*   Updated: 2025/12/06 05:16:53 by lcosta-a         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "libft/libft.h"

t_token	*create_token(char *value, int len, t_token_type type)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	if (value && len > 0)
	{
		token->value = malloc(len + 1);
		if (!token->value)
		{
			free(token);
			return (NULL);
		}
		ft_strncpy(token->value, value, len);
		token->value[len] = '\0';
	}
	else
		token->value = NULL;
	token->type = type;
	token->next = NULL;
	return token;
}

void	add_token(t_token **tokens, t_token *new_token)
{
	t_token	*current;

	if (!new_token)
		return;
	if (!*tokens)
	{
		*tokens = new_token;
		return;
	}
	current = *tokens;
	while (current->next)
		current = current->next;
	current->next = new_token;
}

void	free_tokens(t_token *tokens)
{
	t_token	*current;
	t_token	*next;

	current = tokens;
	while (current)
	{
		next = current->next;
		free(current->value);
		free(current);
		current = next;
	}
}

void	print_tokens(t_token *tokens)
{
	t_token	*current = tokens;

	while (current)
	{
		printf("Token: %s | Type: %d\n", current->value, current->type);
		current = current->next;
	}
}


